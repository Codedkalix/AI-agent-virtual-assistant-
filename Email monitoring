class EmailMonitor:
    def __init__(self, assistant):
        self.assistant = assistant
        self.last_checked = None
        
    def connect_email(self):
        """Connect to email server"""
        try:
            self.mail = imaplib.IMAP4_SSL(
                self.assistant.config["email"]["imap_server"],
                self.assistant.config["email"]["port"]
            )
            # In production, use app-specific passwords or OAuth
            self.mail.login(
                self.assistant.config["email"]["username"],
                self.assistant.config["email"]["password"]
            )
            self.mail.select("inbox")
            return True
        except Exception as e:
            print(f"Email connection error: {e}")
            return False
    
    def check_new_emails(self):
        """Check for new emails and process them"""
        if not self.connect_email():
            return []
            
        try:
            if self.last_checked:
                search_criteria = f'SINCE "{self.last_checked.strftime("%d-%b-%Y")}"'
            else:
                search_criteria = "ALL"
                
            _, message_numbers = self.mail.search(None, search_criteria)
            email_ids = message_numbers[0].split()
            new_emails = []
            
            for email_id in email_ids[-10:]:  # Check last 10 emails
                _, msg_data = self.mail.fetch(email_id, "(RFC822)")
                email_message = email.message_from_bytes(msg_data[0][1])
                
                email_info = self.parse_email(email_message)
                if self.assistant.should_process_email(email_info):
                    self.assistant.process_email(email_info)
                    new_emails.append(email_info)
            
            self.last_checked = datetime.now()
            return new_emails
            
        except Exception as e:
            print(f"Error checking emails: {e}")
            return []
    
    def parse_email(self, email_message):
        """Extract relevant information from email"""
        subject = email_message["subject"] or "No Subject"
        from_ = email_message["from"] or "Unknown Sender"
        date = email_message["date"] or datetime.now().strftime("%a, %d %b %Y %H:%M:%S")
        
        # Extract body
        body = ""
        if email_message.is_multipart():
            for part in email_message.walk():
                if part.get_content_type() == "text/plain":
                    body = part.get_payload(decode=True).decode()
                    break
        else:
            body = email_message.get_payload(decode=True).decode()
        
        return {
            "subject": subject,
            "from": from_,
            "date": date,
            "body": body,
            "priority": self.classify_priority(subject, body, from_)
        }
    
    def classify_priority(self, subject: str, body: str, sender: str) -> str:
        """Classify email priority using AI"""
        prompt = f"""
        Classify this email as HIGH, MEDIUM, or LOW priority:
        Subject: {subject}
        Sender: {sender}
        Body: {body[:500]}
        
        Consider:
        - Urgency indicators
        - Importance of sender
        - Meeting-related content
        - Time-sensitive requests
        
        Respond only with: HIGH, MEDIUM, or LOW
        """
        
        try:
            response = openai.ChatCompletion.create(
                model="gpt-3.5-turbo",
                messages=[{"role": "user", "content": prompt}],
                max_tokens=10
            )
            priority = response.choices[0].message.content.strip().upper()
            return priority if priority in ["HIGH", "MEDIUM", "LOW"] else "MEDIUM"
        except:
            return "MEDIUM"
